/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.30.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { InstantiateMsg, ExecuteMsg, Uint128, Trait, Coin, Character, TraitBundle, CharacterBundle, TraitLootbox, CharacterLootbox, QueryMsg, CharacterBundlesResp, CharacterLootboxesResp, CharactersResp, TraitBundlesResp, TraitLootboxesResp, TraitsResp } from "./CCATMintables.types";
export interface CCATMintablesReadOnlyInterface {
  contractAddress: string;
  traits: () => Promise<TraitsResp>;
  characters: () => Promise<CharactersResp>;
  traitBundles: () => Promise<TraitBundlesResp>;
  characterBundles: () => Promise<CharacterBundlesResp>;
  traitLootboxes: () => Promise<TraitLootboxesResp>;
  characterLootboxes: () => Promise<CharacterLootboxesResp>;
}
export class CCATMintablesQueryClient implements CCATMintablesReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.traits = this.traits.bind(this);
    this.characters = this.characters.bind(this);
    this.traitBundles = this.traitBundles.bind(this);
    this.characterBundles = this.characterBundles.bind(this);
    this.traitLootboxes = this.traitLootboxes.bind(this);
    this.characterLootboxes = this.characterLootboxes.bind(this);
  }

  traits = async (): Promise<TraitsResp> => {
    return this.client.queryContractSmart(this.contractAddress, {
      traits: {}
    });
  };
  characters = async (): Promise<CharactersResp> => {
    return this.client.queryContractSmart(this.contractAddress, {
      characters: {}
    });
  };
  traitBundles = async (): Promise<TraitBundlesResp> => {
    return this.client.queryContractSmart(this.contractAddress, {
      trait_bundles: {}
    });
  };
  characterBundles = async (): Promise<CharacterBundlesResp> => {
    return this.client.queryContractSmart(this.contractAddress, {
      character_bundles: {}
    });
  };
  traitLootboxes = async (): Promise<TraitLootboxesResp> => {
    return this.client.queryContractSmart(this.contractAddress, {
      trait_lootboxes: {}
    });
  };
  characterLootboxes = async (): Promise<CharacterLootboxesResp> => {
    return this.client.queryContractSmart(this.contractAddress, {
      character_lootboxes: {}
    });
  };
}
export interface CCATMintablesInterface extends CCATMintablesReadOnlyInterface {
  contractAddress: string;
  sender: string;
  addTraits: ({
    newTraits
  }: {
    newTraits: Trait[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeTraits: ({
    ids
  }: {
    ids: number[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  addCharacters: ({
    newCharacters
  }: {
    newCharacters: Character[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeCharacters: ({
    ids
  }: {
    ids: number[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  addTraitBundles: ({
    newTraitBundles
  }: {
    newTraitBundles: TraitBundle[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeTraitBundles: ({
    ids
  }: {
    ids: number[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  addCharacterBundles: ({
    newCharacterBundles
  }: {
    newCharacterBundles: CharacterBundle[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeCharacterBundles: ({
    ids
  }: {
    ids: number[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  addTraitLootboxes: ({
    newTraitLootboxes
  }: {
    newTraitLootboxes: TraitLootbox[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeTraitLootboxes: ({
    ids
  }: {
    ids: number[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  addCharacterLootboxes: ({
    newCharacterLootboxes
  }: {
    newCharacterLootboxes: CharacterLootbox[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeCharacterLootboxes: ({
    ids
  }: {
    ids: number[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class CCATMintablesClient extends CCATMintablesQueryClient implements CCATMintablesInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.addTraits = this.addTraits.bind(this);
    this.removeTraits = this.removeTraits.bind(this);
    this.addCharacters = this.addCharacters.bind(this);
    this.removeCharacters = this.removeCharacters.bind(this);
    this.addTraitBundles = this.addTraitBundles.bind(this);
    this.removeTraitBundles = this.removeTraitBundles.bind(this);
    this.addCharacterBundles = this.addCharacterBundles.bind(this);
    this.removeCharacterBundles = this.removeCharacterBundles.bind(this);
    this.addTraitLootboxes = this.addTraitLootboxes.bind(this);
    this.removeTraitLootboxes = this.removeTraitLootboxes.bind(this);
    this.addCharacterLootboxes = this.addCharacterLootboxes.bind(this);
    this.removeCharacterLootboxes = this.removeCharacterLootboxes.bind(this);
  }

  addTraits = async ({
    newTraits
  }: {
    newTraits: Trait[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_traits: {
        new_traits: newTraits
      }
    }, fee, memo, _funds);
  };
  removeTraits = async ({
    ids
  }: {
    ids: number[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_traits: {
        ids
      }
    }, fee, memo, _funds);
  };
  addCharacters = async ({
    newCharacters
  }: {
    newCharacters: Character[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_characters: {
        new_characters: newCharacters
      }
    }, fee, memo, _funds);
  };
  removeCharacters = async ({
    ids
  }: {
    ids: number[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_characters: {
        ids
      }
    }, fee, memo, _funds);
  };
  addTraitBundles = async ({
    newTraitBundles
  }: {
    newTraitBundles: TraitBundle[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_trait_bundles: {
        new_trait_bundles: newTraitBundles
      }
    }, fee, memo, _funds);
  };
  removeTraitBundles = async ({
    ids
  }: {
    ids: number[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_trait_bundles: {
        ids
      }
    }, fee, memo, _funds);
  };
  addCharacterBundles = async ({
    newCharacterBundles
  }: {
    newCharacterBundles: CharacterBundle[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_character_bundles: {
        new_character_bundles: newCharacterBundles
      }
    }, fee, memo, _funds);
  };
  removeCharacterBundles = async ({
    ids
  }: {
    ids: number[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_character_bundles: {
        ids
      }
    }, fee, memo, _funds);
  };
  addTraitLootboxes = async ({
    newTraitLootboxes
  }: {
    newTraitLootboxes: TraitLootbox[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_trait_lootboxes: {
        new_trait_lootboxes: newTraitLootboxes
      }
    }, fee, memo, _funds);
  };
  removeTraitLootboxes = async ({
    ids
  }: {
    ids: number[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_trait_lootboxes: {
        ids
      }
    }, fee, memo, _funds);
  };
  addCharacterLootboxes = async ({
    newCharacterLootboxes
  }: {
    newCharacterLootboxes: CharacterLootbox[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_character_lootboxes: {
        new_character_lootboxes: newCharacterLootboxes
      }
    }, fee, memo, _funds);
  };
  removeCharacterLootboxes = async ({
    ids
  }: {
    ids: number[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_character_lootboxes: {
        ids
      }
    }, fee, memo, _funds);
  };
}